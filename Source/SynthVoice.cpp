/*
  ==============================================================================

    SynthVoice.cpp
    Created: 26 Feb 2023 5:13:20pm
    Author:  Chris

  ==============================================================================
*/

#include "SynthVoice.h"

SynthVoice::SynthVoice()
{
    adsrParams.attack = 0.01f;
    adsrParams.decay = 0;
    adsrParams.sustain = 1;
    adsrParams.release = 0.01f;
    adsr.setParameters(adsrParams);
}


bool 	SynthVoice::canPlaySound(juce::SynthesiserSound* sound)
{
    return dynamic_cast<SynthSound*>(sound);
}


//Called when receiving an external MIDI note on event
//sets the correct frequency for each oscillator and sets the ADSR to the start of the "Attack" position
void 	SynthVoice::startNote(int midiNoteNumber, float velocity, juce::SynthesiserSound* sound, int currentPitchWheelPosition)
{
    adsr.noteOn();
    mainOsc.setFrequency(juce::MidiMessage::getMidiNoteInHertz(midiNoteNumber));
    for (int i = 0; i < 3; i++)
    {
        leftOsc[i].setFrequency(juce::MidiMessage::getMidiNoteInHertz(midiNoteNumber));
        rightOsc[i].setFrequency(juce::MidiMessage::getMidiNoteInHertz(midiNoteNumber));
    }

}


//Called when receiving an external MIDI note off event
//sets the ADSR to the "Release" position
void 	SynthVoice::stopNote(float velocity, bool allowTailOff)
{
    adsr.noteOff();
}


//These two functions take events from the GUI keyboard and call startNote() and stopNote() to process them like normal MIDI input
void 	SynthVoice::handleNoteOn(juce::MidiKeyboardState* source, int midiChannel, int midiNoteNumber, float velocity)
{
    startNote(midiNoteNumber, velocity, nullptr, 0);
}


void 	SynthVoice::handleNoteOff(juce::MidiKeyboardState* source, int midiChannel, int midiNoteNumber, float velocity)
{
    stopNote(0, true);
}


void 	SynthVoice::pitchWheelMoved(int newPitchWheelValue)
{
    //unused
}


void 	SynthVoice::controllerMoved(int controllerNumber, int newControllerValue)
{
    //unused
}


void 	SynthVoice::renderNextBlock(juce::AudioBuffer< float >& outputBuffer, int startSample, int numSamples)
{
    //gets the write pointer for the left & right channel from the audio buffer
    auto leftChannelWriter = outputBuffer.getWritePointer(0);
    auto rightChannelWriter = outputBuffer.getWritePointer(1);

    //this is the sample we're going to create and add to the buffer
    StereoSample sample;

    //gets the next value generated by the ADSR. Used for sample-by-sample processing like we're doing here
    float adsrNextSample;
    
    //iterate sample-by-sample through the current audio block
    for (int i = startSample; i < startSample + numSamples; i++)
    {
        //generates the next ADSR value
        adsrNextSample = adsr.getNextSample();

        //gets the next value from each oscillator and adds it to our sample
        mainOsc.process(sample);
        for (int i = 0; i < 3; i++)
        {
            leftOsc[i].process(sample);
            rightOsc[i].process(sample);
        }

        //make sure to normalize oscillators after adding a bunch of them together
        //this ensures gain never exceeds 1, even though we're adding up 7 full-scale oscillators
        Normalize::normalizeOscillators(sample, 7);

        //multiply our ADSR value into both the left and the right channels
        sample.leftData *= adsrNextSample;
        sample.rightData *= adsrNextSample;

        //calls our Gain object to apply overall gain adjustment to the signal
        Gain::process(sample, gain);

        //and finally, writes the final sample to the left and right channels of the output buffer
        leftChannelWriter[i] += sample.leftData;
        rightChannelWriter[i] += sample.rightData;    
    }

    //once the adsr has finished the release stage of a note, it should call clearCurrentNote() 
    //to tell the synth that this voice is available for use again
    //Then it should reset each oscillators phase, because the 
    //Thickness setting can cause them to get out of phase from each other over time.
    if (!adsr.isActive())
    {
        clearCurrentNote();

        mainOsc.resetPhase();
        for (int i = 0; i < 3; i++)
        {
            leftOsc[i].resetPhase();
            rightOsc[i].resetPhase();
        }
    }
}


//passes in sample rate data to ADSR and oscillators for accurate timing & frequencies
void    SynthVoice::prepare(double sampleRate)
{
    adsr.setSampleRate(sampleRate);

    mainOsc.prepare(sampleRate);
    for (int i = 0; i < 3; i++)
    {
        leftOsc[i].prepare(sampleRate);
        rightOsc[i].prepare(sampleRate);
    }

}


//The rest of these functions make adjustments to any of the parameters the user is given control of via the GUI
//These are called from APValueTreeListener, which responds to changes in the AudioProcessorValueTreeState

void    SynthVoice::setGain(float newGain)
{
    gain = newGain;
}


void    SynthVoice::setAttack(float atk)
{
    adsrParams.attack = atk;
    adsr.setParameters(adsrParams);
    adsr.reset();
}


void    SynthVoice::setDecay(float dec)
{
    adsrParams.decay = dec;
    adsr.setParameters(adsrParams);
    adsr.reset();
}


void    SynthVoice::setSustain(float sus)
{
    adsrParams.sustain = sus;
    adsr.setParameters(adsrParams);
    adsr.reset();
}


void    SynthVoice::setRelease(float rel)
{
    adsrParams.release = rel;
    adsr.setParameters(adsrParams);
    adsr.reset();
}


void    SynthVoice::setPulseWidth(float pulseWidth)
{
    mainOsc.setPulseWidth(pulseWidth);
    for (int i = 0; i < 3; i++)
    {
        leftOsc[i].setPulseWidth(pulseWidth);
        rightOsc[i].setPulseWidth(pulseWidth);
    }
}


void    SynthVoice::setThickness(float thickness)
{
    //these crazy looking equations just lerp the detune values so that when:
    //thickness = 0, detune factor = 1 and when
    //thickness = 1, detune factor = detuneUp or detuneDown

    //ideally tuning one oscillator up and another down by an equal amount should result in a percieved pitch that's the same as the original frequency

    leftOsc[0].setFineTune((detuneUp - 1) * thickness + 1);
    rightOsc[0].setFineTune((detuneDown - 1) * thickness + 1);

    //detune these voices 2/3rds as much as the first set
    leftOsc[1].setFineTune((detuneDown - 1) * (thickness * 0.666f) + 1);
    rightOsc[1].setFineTune((detuneUp - 1) * (thickness * 0.666f) + 1);

    //detune these voices 1/3rd as much as the first set
    leftOsc[2].setFineTune((detuneUp - 1) * (thickness * 0.333f) + 1);
    rightOsc[2].setFineTune((detuneDown - 1) * (thickness * 0.333f) + 1);

}


void    SynthVoice::setWidth(float width)
{
    //pan these bad boys out

    leftOsc[0].setPan(-width);
    leftOsc[1].setPan(-width * 0.666f);
    leftOsc[2].setPan(-width * 0.333f);

    rightOsc[0].setPan(width);
    rightOsc[1].setPan(width * 0.666f);
    rightOsc[2].setPan(width * 0.333f);

}


void    SynthVoice::changeOsc(Oscillator::Waveform newOsc)
{
    mainOsc.setWaveShape(newOsc);
    for (int i = 0; i < 3; i++)
    {
        leftOsc[i].setWaveShape(newOsc);
        rightOsc[i].setWaveShape(newOsc);
    }
}